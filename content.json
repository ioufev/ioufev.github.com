{"meta":{"title":"RUBG","subtitle":null,"description":"记录生活","author":"ioufev","url":"http://ious.ml"},"pages":[{"title":"文章分类","date":"2019-01-18T08:33:57.000Z","updated":"2019-01-18T09:00:33.024Z","comments":true,"path":"categories/index.html","permalink":"http://ious.ml/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-01-18T08:33:05.000Z","updated":"2019-01-18T09:00:04.390Z","comments":true,"path":"tags/index.html","permalink":"http://ious.ml/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"搭建Github博客：Next主题配置","slug":"搭建Github博客：Next主题配置","date":"2019-01-18T02:07:33.000Z","updated":"2019-01-18T08:39:26.593Z","comments":true,"path":"2019/01/18/da-jian-github-bo-ke-next-zhu-ti-pei-zhi/","link":"","permalink":"http://ious.ml/2019/01/18/da-jian-github-bo-ke-next-zhu-ti-pei-zhi/","excerpt":"介绍搭建Github博客：Next主题配置","text":"介绍搭建Github博客：Next主题配置 NexT 使用文档：http://theme-next.iissnan.com 主题配置文件路径：D:\\CODE\\blog\\themes\\next\\_config.yml 站点配置文件路径：D:\\CODE\\blog\\_config.yml 主题设定：http://theme-next.iissnan.com/getting-started.html#theme-settings 主题配置：http://theme-next.iissnan.com/theme-settings.html 第三方服务集成：http://theme-next.iissnan.com/third-party-services.html#comment-system 1.主题设定选择「Scheme」Next主题还有4种风格供我们选择，预览 Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Gemini - Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。 设置「语言」编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下：1language: zh-CN 比如，我的语言包路径是：D:\\CODE\\blog\\themes\\next\\languages 设置「菜单」菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。 编辑 主题配置文件，修改以下内容： （1）设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。 菜单示例配置1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html NexT 默认的菜单项有： 键值 设定值 显示文本（简体中文） home home: / 主页 archives archives: /archives 归档页 categories categories: /categories 分类页(需要手动创建) tags tags: /tags 标签页(需要手动创建) about about: /about 关于页面(需要手动创建) commonweal commonweal: /404.html 公益 404 (需要手动创建) （2）设置菜单项的显示文本。 在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-CN.yml，在 menu 字段下添加一项： 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 （3）设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 菜单图标配置示例 123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 设置「侧栏」默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。 可以通过修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。 （1）设置侧栏的位置，修改 sidebar.position 的值，支持的选项有：12345#left - 靠左放置#right - 靠右放置sidebar: position: left 目前仅 Pisces Scheme 支持 position 配置 （2）设置侧栏显示的时机，修改 sidebar.display 的值，支持的选项有： 123456#post - 默认行为，在文章页面（拥有目录列表）时显示#always - 在所有页面中都显示#hide - 在所有页面中都隐藏（可以手动展开）#remove - 完全移除sidebar: display: post 设置「头像」编辑 主题配置文件， 修改字段 avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是： 地址 值 完整的互联网 URI http://example.com/avatar.png 站点内的地址 将头像放置主题目录下的 source/uploads/ （新建 uploads 目录若不存在）配置为：avatar: /uploads/avatar.png 或者 放置在 source/images/ 目录下 配置为：avatar: /images/avatar.png 头像设置示例1avatar: http://example.com/avatar.png 设置「作者昵称」编辑 站点配置文件， 设置 author 为你的昵称。 站点描述编辑 站点配置文件， 设置 description 字段为你的站点描述。站点描述可以是你喜欢的一句签名:) 2.主题配置设置 RSSNexT 中 RSS 有三个设置选项，满足特定的使用场景。 更改 主题配置文件，设定 rss 字段的值： false：禁用 RSS，不在页面上显示 RSS 连接。 留空：使用 Hexo 生成的 Feed 链接。 你可以需要先安装 hexo-generator-feed 插件。 具体的链接地址：适用于已经烧制过 Feed 的情形。 添加「标签」页面新建「标签」页面，并在菜单中显示「标签」链接。「标签」页面将展示站点的所有标签，若你的所有文章都未包含标签，此页面将是空的。 底下代码是一篇包含标签的文章的例子： 12345title: 标签测试文章tags: - Testing - Another Tag--- 添加「分类」页面新建「分类」页面，并在菜单中显示「分类」链接。「分类」页面将展示站点的所有分类，若你的所有文章都未包含分类，此页面将是空的。 底下代码是一篇包含分类的文章的例子： 123title: 分类测试文章categories: Testing--- 设置字体为了解决 Google Fonts API 不稳定的问题，NexT 在 5.0.1 中引入此特性。 通过此特性，你可以指定所使用的字体库外链地址；与此同时，NexT 开放了 5 个特定范围的字体设定，他们是： 全局字体：定义的字体将在全站范围使用 标题字体：文章内标题的字体（h1, h2, h3, h4, h5, h6） 文章字体：文章所使用的字体 Logo字体：Logo 所使用的字体 代码字体： 代码块所使用的字体 设置代码高亮主题NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 normal，night， night blue， night bright， night eighties： 高亮主题设置示例 1234# Code Highlight theme# Available value: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal 侧边栏社交链接侧栏社交链接的修改包含两个部分，第一是链接，第二是链接图标。 两者配置均在 主题配置文件 中。 链接放置在 social 字段下，一行一个链接。其键值格式是 显示文本: 链接地址。 配置示例12345678# Social linkssocial: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name 微博: http://weibo.com/your-user-name 豆瓣: http://douban.com/people/your-user-name 知乎: http://www.zhihu.com/people/your-user-name # 等等 设定链接的图标，对应的字段是 social_icons。其键值格式是 匹配键: Font Awesome 图标名称， 匹配键 与上一步所配置的链接的 显示文本 相同（大小写严格匹配），图标名称 是 Font Awesome 图标的名字（不必带 fa- 前缀）。 enable 选项用于控制是否显示图标，你可以设置成 false 来去掉图标。 配置示例1234567# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter 微博: weibo 开启打赏功能越来越多的平台（微信公众平台，新浪微博，简书，百度打赏等）支持打赏功能，付费阅读时代越来越近，特此增加了打赏功能，支持微信打赏和支付宝打赏。 只需要 主题配置文件 中填入 微信 和 支付宝 收款二维码图片地址 即可开启该功能。 打赏功能配置示例 123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /path/to/wechat-reward-imagealipay: /path/to/alipay-reward-image 友情链接编辑 主题配置文件 添加： 友情链接配置示例12345# titlelinks_title: Linkslinks: MacTalk: http://macshuo.com/ Title: http://example.com/ 站点建立时间这个时间将在站点的底部显示，例如 © 2013 - 2015。 编辑 主题配置文件 配置示例1since: 2013 订阅微信公众号在每篇文章的末尾显示微信公众号二维码，扫一扫，轻松订阅博客。 在微信公众号平台下载您的二维码，并将它存放于博客source/uploads/目录下。 设置「动画效果」NexT 默认开启动画效果，效果使用 JavaScript 编写，因此需要等待 JavaScript 脚本完全加载完毕后才会显示内容。 如果您比较在乎速度，可以将设置此字段的值为 false 来关闭动画。 编辑 主题配置文件， 搜索 use_motion，根据您的需求设置值为 true 或者 false 即可：12use_motion: true # 开启动画效果use_motion: false # 关闭动画效果 设置「背景动画」NexT 自带两种背景动画效果 编辑 主题配置文件， 搜索 canvas_nest 或 three_waves，根据您的需求设置值为 true 或者 false 即可： canvas_nest 配置示例123# canvas_nestcanvas_nest: true //开启动画canvas_nest: false //关闭动画 1234three_waves 配置示例# three_wavesthree_waves: true //开启动画three_waves: false //关闭动画 3.配置记录头像搜索：avatar 比如我的头像是放在D:\\CODE\\blog\\themes\\next\\source\\images\\文件夹下的Elena.jpg 123# Sidebar Avataravatar: url: /images/Elena.jpg #/images/avatar.gif 手动页面","categories":[{"name":"生活","slug":"生活","permalink":"http://ious.ml/categories/生活/"}],"tags":[{"name":"计算机协议","slug":"计算机协议","permalink":"http://ious.ml/tags/计算机协议/"}]},{"title":"前后端均适用的网络知识点大全","slug":"前后端均适用的网络知识点大全","date":"2019-01-17T07:16:07.000Z","updated":"2019-01-18T08:39:19.885Z","comments":true,"path":"2019/01/17/qian-hou-duan-jun-gua-yong-de-wang-luo-zhi-shi-dian-da-quan/","link":"","permalink":"http://ious.ml/2019/01/17/qian-hou-duan-jun-gua-yong-de-wang-luo-zhi-shi-dian-da-quan/","excerpt":"前后端均适用的网络知识点大全","text":"前后端均适用的网络知识点大全 来源：前端指南 https://mp.weixin.qq.com/s/hOKfbgd-nRn2lboXMCiY8w http 响应常见状态码 100-199 : 表示成功接收请求, 要求客户端继续提交下一次请求才能完成整个处理过程 200-299: 表示成果接收请求并已完成整个处理过程. 常用 200 300-399: 为完成请求, 客户需进一步细化需求: 例如: 请求的资源已经移动一个新地址, 常用 302(重定向), 307 和 304(拿缓存) 400-499: 客户端的请求有错误, 包含语法错误或者不能正确执行. 常用 404(请求的资源在 web 服务器中没有) 403(服务器拒绝访问, 权限不够) 500-599: 服务器端出现错误 常用： 200 正常，表示一切正常, 返回的是正常请求结果 302/307 临时重定向，指出请求的文档已被临时移动到别处, 此文档的新的 url 在 location 响应头中给出 304 未修改，表示客户机缓存的版本是最新的, 客户机应该继续使用它 403 禁止，服务器理解客户端请求, 但拒绝处理它, 通常用于服务器上文件或目录的权限设置所致 404 找不到，服务器上不存在客户机所请求的资源 500 服务器内部错误，服务器端的 cgi, asp, jsp 等程序发生错误 简述 http 1.1 与 http 1.0 的区别 http 1.0 对于每个连接都得建立一次连接, 一次只能传送一个请求和响应, 请求就会关闭, http1.0 没有 Host 字段 而 http1.1 在同一个连接中可以传送多个请求和响应, 多个请求可以重叠和同时进行, http1.1 必须有 host 字段 http1.1 中引入了 ETag 头, 它的值 entity tag 可以用来唯一的描述一个资源. 请求消息中可以使用 If-None-Match 头域来匹配资源的 entitytag 是否有变化 http1.1 新增了 Cache-Control 头域(消息请求和响应请求都可以使用), 它支持一个可扩展的指令子集 http1.0 中只定义了 16 个状态响应码, 对错误或警告的提示不够具体. http1.1 引入了一个 Warning 头域, 增加对错误或警告信息的描述. 且新增了 24 个状态响应码 说一下 TCP 三次握手和四次挥手 建立 TCP 连接需要三次握手:三次握手: 首先 Client 端发送连接请求报文，Server 段接受连接后回复 ACK 报文，并为这次连接分配资源。Client 端接收到 ACK 报文后也向 Server 段发生 ACK 报文，并分配资源，这样 TCP 连接就建立了。 第一步: 客户机的 TCP 先向服务器的 TCP 发送一个连接请求报文. 这个特殊的报文中不含应用层数据, 其首部中的 SYN 标志位被置 1. 另外, 客户机会随机选择一个起始序号 seq=x(连接请求报文不携带数据,但要消耗掉一个序号) 第二步: 服务器端的 TCP 收到连接请求报文后, 若同意建立连接, 就向客户机发送请求, 并为该 TCP 连接分配 TCP 缓存和变量. 在确认报文中,SYN 和 ACK 位都被置为 1, 确认号字段的值为 x+1, 并且服务器随机产生起始序号 seq=y(确认报文不携带数据, 但也要消耗掉一个序号). 确认报文同样不包含应用层数据. 第三步: 当客户机收到确认报文后, 还要向服务器给出确认, 并且也要给该连接分配缓存和变量. 这个报文的 ACK 标志位被置为 1, 序号字段为 x+1, 确认号字段为 y+1 四次挥手 第一步: 客户机打算关闭连接,就向其 TCP 发送一个连接释放报文,并停止再发送数据,主动关闭 TCP 连接, 该报文的 FIN 标志位被置 1, seq=u, 它等于前面已经传送过的数据的最后一个字节的序号加 1(FIN 报文即使不携带数据,也要消耗掉一个序号) 第二步: 服务器接收连接释放报文后即发出确认, 确认号是 ack=u+1, 这个报文自己的序号是 v, 等于它前面已传送过的数据的最后一个自己的序号加 1. 此时, 从客户机到服务器这个方向的连接就释放了, TCP 连接处于半关闭状态. 但服务器若发送数据, 客户机仍要接收, 即从服务器到客户机的连接仍未关闭. 第三步: 若服务器已经没有了要向客户机发送的数据, 就通知 TCP 释放连接, 此时其发出 FIN=1 的连接释放报文 第四步: 客户机收到连接释放报文后, 必须发出确认. 在确认报文中, ACK 字段被置为 1, 确认号 ack=w+1, 序号 seq=u+1. 此时, TCP 连接还没有释放掉, 必须经过等待计时器设置的时间 2MSL 后, A 才进入到连接关闭状态. 计算机网络体系结构有哪些 学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。 应用层应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。 域名系统 域名系统(Domain Name System 缩写 DNS，Domain Name 被译为域名)是因特网的一项核心服务，它作为可以将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 www.ibm.com、Oracle 公司的域名是 www.oracle.com、Cisco 公司的域名是 www.cisco.com 等。 http 协议 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科） 运输层运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。 运输层常用的两种协议TCP UDP 传输控制协议 TCP（Transmisson Control Protocol）–提供面向连接的，可靠的数据传输服务。 用户数据协议 UDP（User Datagram Protocol）–提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。 UDP的主要特点 UDP 是无连接的； UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）； UDP 是面向报文的； UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）； UDP 支持一对一、一对多、多对一和多对多的交互通信； UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。 TCP的主要特点 TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）； 每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的（一对一）； TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达； TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据； 面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。 网络层在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。 这里要注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。 这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称. 互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。 数据链路层数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装程帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。 在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。 物理层在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。 在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的 TCP/IP 并不一定单指 TCP 和 IP 这两个具体的协议，而往往表示互联网所使用的整个 TCP/IP 协议族。 上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下。图片来源：https://blog.csdn.net/yaopeng_2005/article/details/7064869 HTTP与HTTPS的区别（常考） Http 协议运行在 TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份；Https 是身披 SSL(Secure Socket Layer)外壳的 Http，运行于 SSL 上，SSL 运行于 TCP 之上，是添加了加密和认证机制的 HTTP。二者之间存在如下不同： 端口不同：Http 与 Http 使用不同的连接方式，用的端口也不一样，前者是 80，后者是 443； 资源消耗：和 HTTP 通信相比，Https 通信会由于加减密处理消耗更多的 CPU 和内存资源； 开销：Https 通信需要证书，而证书一般需要向认证机构购买； Https 的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。 对称加密与非对称加密 对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。 TCP协议如何来保持传输的可靠性TCP 提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用 TCP 的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个 TCP 连接。在一个 TCP 连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过 TCP 链接交换 8bit 字节构成的字节流，TCP 不在字节流中插入记录标识符。 对于可靠性，TCP 通过以下方式进行保证： 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据； 对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层； 丢弃重复数据：对于重复数据，能够丢弃重复数据； 应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒； 超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段； 流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 参考链接 计算机网络面试问题集锦 简述 查找域名对应的IP地址这一步包括 DNS 具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存… 浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）； 搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）； 搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）； 操作系统将域名发送至 LDNS（本地区域名服务器），LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求： LDNS 向 Root Name Server （根域名服务器，如 com、net、org 等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的顶级域名服务器的地址； LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com 域名服务器地址； LDNS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址； LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来； 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来； 从输入 URL 到页面加载发生了什么【必考】总体来说分为以下几个过程: DNS 解析 TCP 连接 发送 HTTP 请求 服务器处理请求并返回 HTTP 报文 浏览器解析渲染页面 连接结束 这道题的区分度很高建议大家仔细查看下面这篇文章从输入 URL 到页面加载发生了什么 HTTP的几种请求方法的用途 GET 方法：发送一个请求来取得服务器上的某一资源 POST 方法：向 URL 指定的资源提交数据或附加新的数据 PUT 方法：跟 POST 方法很像，也是想服务器提交数据。但是，它们之间有不同。PUT 指定了资源在服务器上的位置，而 POST 没有 HEAD 方法：只请求页面的首部 DELETE 方法：删除服务器上的某资源 OPTIONS 方法：它用于获取当前 URL 所支持的方法。如果请求成功，会有一个 Allow 的头包含类似“GET,POST”这样的信息 TRACE 方法：TRACE 方法被用于激发一个远程的，应用层的请求消息回路 CONNECT 方法：把请求连接转换到透明的 TCP/IP 通道 127.0.0.1 与 192.168.0.1 有什么区别【可能考】首先明确二者没有区别！两个 IP 地址的角度不一样，127.0.0.1 是从 IETF（因特尔工程任务组）规定看，是保留给本机使用的 IP 地址，所有的计算机默认都是相同的。而 192.168.0.1 其实只是 IETF 在 c 类网址中，专门留出给专用网络用的一个网段中的一个 IP 而已，该网段包含了 192.168.0.1 到 192.168.255.255 中所有的 IP 地址。 五类 ip 地址的范围IP 地址分为 A,B,C,D,E 五类。 网络号：用于识别主机所在的网络； 主机号：用于识别该网络中的主机。 其中 A 类分配给政府机关使用，B 类地址给大中型企业使用，C 类地址给个人使用。这三种是主要的。 IP 地址分为五类，A 类保留给政府机构，B 类分配给中等规模的公司，C 类分配给任何需要的人，D 类用于组播，E 类用于实验，各类可容纳的地址数目不同。 其中 A 类、B 类、和 C 类这三类地址用于 TCP/IP 节点，其它两类 D 类和 E 类被用于特殊用途。 A、B、C 三类 IP 地址的特征：当将 IP 地址写成二进制形式时，A 类地址的第一位总是 O，B 类地址的前两位总是 10，C 类地址的前三位总是 110。 A 类地址 ⑴ A 类地址第 1 字节为网络地址，其它 3 个字节为主机地址。 ⑵ A 类地址范围：1.0.0.1—126.155.255.254 ⑶ A 类地址中的私有地址和保留地址： ① 10.X.X.X 是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址）。 ② 127.X.X.X 是保留地址，用做循环测试用的。 B 类地址 ⑴ B 类地址第 1 字节和第 2 字节为网络地址，其它 2 个字节为主机地址。 ⑵ B 类地址范围：128.0.0.1—191.255.255.254。 ⑶ B 类地址的私有地址和保留地址 ① 172.16.0.0—172.31.255.255 是私有地址 ② 169.254.X.X 是保留地址。如果你的 IP 地址是自动获取 IP 地址，而你在网络上又没有找到可用的 DHCP 服务器。就会得到其中一个 IP。 C 类地址 ⑴ C 类地址第 1 字节、第 2 字节和第 3 个字节为网络地址，第 4 个个字节为主机地址。另外第 1 个字节的前三位固定为 110。 ⑵ C 类地址范围：192.0.0.1—223.255.255.254。 ⑶ C 类地址中的私有地址： 192.168.X.X 是私有地址。 D 类地址 ⑴ D 类地址不分网络地址和主机地址，它的第 1 个字节的前四位固定为 1110。 ⑵ D 类地址范围：224.0.0.1—239.255.255.254 E 类地址 ⑴ E 类地址也不分网络地址和主机地址，它的第 1 个字节的前五位固定为 11110。 ⑵ E 类地址范围：240.0.0.1—255.255.255.254 HTTP 长连接、短连接在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。 而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码： Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。 HTTP 长连接、短连接究竟是什么？ 如何理解 HTTP 协议是无状态的【常考】HTTP 协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP 是一个无状态的面向连接的协议，无状态不代表 HTTP 不能保持 TCP 连接，更不能代表 HTTP 使用的是 UDP 协议（无连接）。 各种协议与 HTTP 协议之间的关系一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。 Socket 连接与 HTTP 连接的联系与区别（需了解）由于通常情况下 Socket 连接就是 TCP 连接，因此 Socket 连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。 而 HTTP 连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。 很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是 Socket 连接，服务器就可以直接将数据传送给客户端;若双方建立的是 HTTP 连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。 http 报文大小限制如前所述，一个 HTTP 报文包含起始行，头域和消息体，HTTP 协议本身并没有对报文中任一部分的长度做限制，也就是说，理论上一个请求 URI 可以无限长，头域可以无限多，请求体可以无限大。但在实际场景下，请求 URI 的长度会受到浏览器的限制，如果在浏览器中输入过长的 URL，那么浏览器会自动进行截断。而服务器出于安全性和效率的考虑，也会对头域和消息体的大小作出一定的限制。 http(tcp) 报文结构（必考）例如一个 100kb 的 HTML 文档需要传送到另外一台计算机，并不会整个文档直接传送过去，可能会切割成几个部分，比如四个分别为 25kb 的数据段。而每个数据段再加上一个 TCP 首部，就组成了 TCP 报文。 TCP 报文 (Segment)，包括首部和数据部分。 首部： 源端口 source port 目的端口 destination port 序号 sequence number 确认号 acknowledgment number 数据偏移 offset 保留 reserved 标志位 tcp flags 窗口大小 window size 检验和 checksum 紧急指针 urgent pointer 选项 tcp options HTTP 的缓存机制(常考)Http 的缓存主要利用 header 里的两个字段来控制： Cache-control主要包含以及几个字段： private:则只有客户端可以缓存 public:客户端和代理服务器都可以缓存 max-age:缓存的过期时间 no-cache:需要使用对比缓存来验证缓存数据 no-store:所有内存都不会进行缓存 ETag:即用来进行对比缓存，Etag 是服务端资源的一个标识码 当客户端发送第一次请求时服务端会下发当前请求资源的标识码 Etag，下次再请求时，客户端则会通过 header 里的 If-None-Match 将这个标识码 Etag 带上，服务端将客户端传来的 Etag 与最新的资源 Etag 做对比，如果一样，则表示资源没有更新，返回 304。 通过 Cache-control 和 Etag 的配合来实现 Http 的缓存机制。 CookieCookie 就是用来在本地缓存记住一些状态的，一个 Cookie 一般都包含 domin(所属域)、path、Expires(过期时间)等几个属性。服务端可以通过在响应头里的 set-cookies 来将状态写入客户端的 Cookie 里。下次客户端发起请求时可以将 Co Http 2.0 与 http1.x 相比有什么优点(常考) 二进制格式:http1.x 是文本协议，而 http2.0 是二进制以帧为基本单位，是一个二进制协议，一帧中除了包含数据外同时还包含该帧的标识：Stream Identifier，即标识了该帧属于哪个 request,使得网络传输变得十分灵活。 多路复用: 一个很大的改进，原先 http1.x 一个连接一个请求的情况有比较大的局限性，也引发了很多问题，如建立多个连接的消耗以及效率问题。 http1.x 为了解决效率问题，可能会尽量多的发起并发的请求去加载资源，然而浏览器对于同一域名下的并发请求有限制，而优化的手段一般是将请求的资源放到不同的域名下来突破这种限制。 而 http2.0 支持的多路复用可以很好的解决这个问题，多个请求共用一个 TCP 连接，多个请求可以同时在这个 TCP 连接上并发，一个是解决了建立多个 TCP 连接的消耗问题，一个也解决了效率的问题。那么是什么原理支撑多个请求可以在一个 TCP 连接上并发呢？基本原理就是上面的二进制分帧，因为每一帧都有一个身份标识，所以多个请求的不同帧可以并发的无序发送出去，在服务端会根据每一帧的身份标识，将其整理到对应的 request 中。 header 头部压缩:主要是通过压缩 header 来减少请求的大小，减少流量消耗，提高效率。因为之前存在一个问题是，每次请求都要带上 header，而这个 header 中的数据通常是一层不变的。 支持服务端推送 流量控制流量控制是对一条通信路径上的流量进行控制，就是发送方通过获取接收方的回馈来动态调整发送的速率，来达到控制流量的效果，其目的是保证发送者的发送速度不超过接收者的接收速度。 拥塞控制拥塞控制是对整个通信子网的流量进行控制，属于全局控制。 慢开始+拥塞避免 先来看一张经典的图： 一开始使用慢启动，即拥塞窗口设为 1，然后拥塞窗口指数增长到慢开始的门限值(ssthresh=16),则切换为拥塞避免,即加法增长，这样增长到一定程度，导致网络拥塞，则此时会把拥塞窗口重新降为 1，即重新慢开始，同时调整新的慢开始门限值为 12，之后以此类推。 快重传+快恢复 快重传:上面我们说的重传机制都是等到超时还未收到接收方的回复，才开始进行重传。而快重传的设计思路是：如果发送方收到 3 个重复的接收方的 ACK，就可以判断有报文段丢失，此时就可以立即重传丢失的报文段，而不用等到设置的超时时间到了才开始重传，提高了重传的效率。 快恢复：上面的拥塞控制会在网络拥塞时将拥塞窗口降为 1，重新慢开始，这样存在的一个问题就是网络无法很快恢复到正常状态。快恢复就是来优化这个问题的，使用快恢复，则出现拥塞时，拥塞窗口只会降低到新的慢开始门阀值（即 12），而不会降为 1，然后直接开始进入拥塞避免加法增长，如下图所示： 推荐阅读 WEB即时通信最佳实践 前端通信进阶 WebSocket 通信过程与实现","categories":[{"name":"生活","slug":"生活","permalink":"http://ious.ml/categories/生活/"}],"tags":[{"name":"计算机协议","slug":"计算机协议","permalink":"http://ious.ml/tags/计算机协议/"}]},{"title":"PLC和OPC","slug":"PLC和OPC","date":"2019-01-17T07:14:43.610Z","updated":"2019-01-18T07:37:37.120Z","comments":true,"path":"2019/01/17/plc-he-opc/","link":"","permalink":"http://ious.ml/2019/01/17/plc-he-opc/","excerpt":"本文介绍Java的OPC通信实现","text":"本文介绍Java的OPC通信实现 1.PLC和OPC PLC： 西门子的S7 300 OPC： 实验用模拟OPCServer（50M）：MatrikonOPC，百度网盘，密码: mcur 实际OPCServer使用（450M，中文）：KEPServer V6，百度网盘 ，密码: ykj2 2.连接测试 MatrikonOPC 使用Matrikon OPC Server Simulation KEPServer V6 使用KEPServerEX 6 Configuration 配置OPCserver OPC和DCOM配置 3.通信实现 最重要参考：Java OPC client开发踩坑记 Utgard 官网：http://openscada.org/projects/utgard/ 编程指导 博客参考 Java语言开发OPC之Utgard的数据访问方式 utgard访问OPC server github上的 OPC_Client，笔记 github上的测试例子 JeasyOPC java读取opc服务器 JAVA使用JeasyOPC读取OPC 服务器数据 OPC 通讯 Demo 4.实现过程 先恶补了一下OPC的概念： OPC 协议认识 OPC技术学习总结 先使用MatrikonOPC模拟实现： OPC测试常用的OPCClient和OPCServer软件推荐 我的目的就是写一个类似的Java版的Client来连接OPC Server 使用Matrikon OPC Server Simulation 关于OPC UA 支持的OPC UA的西门子PLC至少是s7-1500 我的s7-300是没法用的，所以就不需要搜集OPC UA的资料了 关于用Java实现 C#和C++都不用配置，直接调用函数 既然是非要用Java，那就别想太方便。 关于Utgard utgard是一个开源的项目，基于j-interop做的，用于和OPC SERVER通讯。 j-interop是纯java封装的用于COM/DCOM通讯的开源项目，这样就不必使用JNI 关于JeasyOPC JeasyOPC源码下载 借助一个dll库来实现的和OPCServer的通信，但是JCustomOpc.dll，，太老了，而且支持只32位系统 实现 当然选Utgard 过程就是把需要的jar包找到， 然后复制编程指导里的读写代码，读就是启动线程一直监控读值，写就是直接写 测试： 参考OPC_Client里的例子 关于配置文件的代码直接复制用了 例子实际也用不到，试了试，，因为实际只需要读写变量就可以了 问题： 在虚拟机里用localhost一直报错，要写固定IP才行 需要下载一个bcprov-jdk16-146.jar包，因为报安全算法错误 位置：”C:\\Program Files\\Java\\jdk1.8.0_92\\jre\\lib\\ext\\bcprov-jdk16-146.jar” java.security位置：”C:\\Program Files\\Java\\jdk1.8.0_92\\jre\\lib\\security\\java.security” 在java.security最后添加一句：security.provider.x=org.bouncycastle.jce.provider.BouncyCastleProvider 5.代码 下载：链接: 百度网盘 ，密码: x7f1 截图： 需求读一次还是循环读，写一次还是一直写 读值或者写值的类型如果是数组怎么办? 根据实际使用，对例子加了注释，方便理解 读值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.concurrent.Executors; import org.jinterop.dcom.common.JIException;import org.openscada.opc.lib.common.ConnectionInformation;import org.openscada.opc.lib.da.AccessBase;import org.openscada.opc.lib.da.DataCallback;import org.openscada.opc.lib.da.Item;import org.openscada.opc.lib.da.ItemState;import org.openscada.opc.lib.da.Server;import org.openscada.opc.lib.da.SyncAccess; public class UtgardTutorial1 &#123; public static void main(String[] args) throws Exception &#123; // 连接信息 final ConnectionInformation ci = new ConnectionInformation(); ci.setHost(\"192.168.0.1\"); // 电脑IP ci.setDomain(\"\"); // 域，为空就行 ci.setUser(\"OPCUser\"); // 电脑上自己建好的用户名 ci.setPassword(\"123456\"); // 用户名的密码 // 使用MatrikonOPC Server的配置 // ci.setClsid(\"F8582CF2-88FB-11D0-B850-00C0F0104305\"); // final String itemId = \"u.u\"; //项的名字按实际 // 使用KEPServer的配置 ci.setClsid(\"7BC0CC8E-482C-47CA-ABDC-0FE7F9C6E729\"); // Clsid，软件在注册表的ID final String itemId = \"u.u.u\"; // 项的名字按实际 // final String itemId = \"通道 1.设备 1.标记 1\"; // 启动服务 final Server server = new Server(ci, Executors.newSingleThreadScheduledExecutor()); try &#123; // 连接到服务 server.connect(); // add sync access, poll every 500 ms // 启动一个同步的access用来读取地址上的值，线程池每500ms读值一次 // 这个是用来循环读值的，只读一次值不用这样 final AccessBase access = new SyncAccess(server, 500); // 这是个回调函数，就是读到值后执行这个打印，是用匿名类写的，当然也可以写到外面去 access.addItem(itemId, new DataCallback() &#123; @Override public void changed(Item item, ItemState state) &#123; int type = itemState.getValue().getType(); System.out.println(\"监控项的数据类型是：-----\" + type); //类型是个数字，用常量定义的 System.out.println(\"监控项的详细信息是：-----\" + state); // 如果读到是short类型的值 if (type == JIVariant.VT_I2) &#123; short n = state.getValue().getObjectAsShort(); System.out.println(\"-----short类型值： \" + n); &#125; // 如果读到是字符串类型的值 if(type == JIVariant.VT_BSTR) &#123; // 字符串的类型是8 JIString value = itemState.getValue().getObjectAsString(); // 按字符串读取 String str = value.getString(); // 得到字符串 System.out.println(\"-----String类型值： \" + str); &#125; &#125; &#125;); // start reading，开始读值 access.bind(); // wait a little bit，有个10秒延时 Thread.sleep(10 * 1000); // stop reading，停止读取 access.unbind(); &#125; catch (final JIException e) &#123; System.out.println(String.format(\"%08X: %s\", e.getErrorCode(), server.getErrorMessage(e.getErrorCode()))); &#125; &#125;&#125; 写值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit; import org.jinterop.dcom.common.JIException;import org.jinterop.dcom.core.JIVariant;import org.openscada.opc.lib.common.ConnectionInformation;import org.openscada.opc.lib.da.AccessBase;import org.openscada.opc.lib.da.DataCallback;import org.openscada.opc.lib.da.Group;import org.openscada.opc.lib.da.Item;import org.openscada.opc.lib.da.ItemState;import org.openscada.opc.lib.da.Server;import org.openscada.opc.lib.da.SyncAccess; public class UtgardTutorial2 &#123; public static void main(String[] args) throws Exception &#123; // 连接信息 final ConnectionInformation ci = new ConnectionInformation(); ci.setHost(\"192.168.0.1\"); // 电脑IP ci.setDomain(\"\"); // 域，为空就行 ci.setUser(\"OPCUser\"); // 用户名，配置DCOM时配置的 ci.setPassword(\"123456\"); // 密码 // 使用MatrikonOPC Server时的配置 // ci.setClsid(\"F8582CF2-88FB-11D0-B850-00C0F0104305\"); // final String itemId = \"u.u\"; //项的名字按实际 // 使用KEPServer时的配置 ci.setClsid(\"7BC0CC8E-482C-47CA-ABDC-0FE7F9C6E729\"); // Clsid，软件在注册表的ID final String itemId = \"u.u.u\"; // 项的名字按实际 // final String itemId = \"通道 1.设备 1.标记 1\"; // create a new server，启动服务 final Server server = new Server(ci, Executors.newSingleThreadScheduledExecutor()); try &#123; // connect to server，连接到服务 server.connect(); // 连接成功后就可以在别的地方使用了 // 使用方法就是前面声明变量：private Server server; // 然后连接成功后给变量变量赋值：this.server = server; // add sync access, poll every 500 ms // 启动一个同步的access用来读取地址上的值，线程池每500ms读值一次 // 这个是用来循环读值的，只读一次值不用这样 final AccessBase access = new SyncAccess(server, 500); // 这是个回调函数，就是读到值后执行再执行下面的代码，是用匿名类写的，当然也可以写到外面去 access.addItem(itemId, new DataCallback() &#123; @Override public void changed(Item item, ItemState state) &#123; // also dump value try &#123; if (state.getValue().getType() == JIVariant.VT_UI4) &#123; // 如果读到的值类型时UnsignedInteger，即无符号整形数值 System.out.println(\"&lt;&lt;&lt; \" + state + \" / value = \" + state.getValue().getObjectAsUnsigned().getValue()); &#125; else &#123; System.out.println(\"&lt;&lt;&lt; \" + state + \" / value = \" + state.getValue().getObject()); &#125; &#125; catch (JIException e) &#123; e.printStackTrace(); &#125; // 如果读到的值是数组类型呢，下面为读取Float类型的数组 if (type == 8196) &#123; // 8196是打印state.getValue().getType()得到的 JIArray jarr = state.getValue().getObjectAsArray(); // 按数组读取 Float[] arr = (Float[]) jarr.getArrayInstance(); // 得到数组 String value = \"\"; for (Float f : arr) &#123; value = value + f + \",\"; &#125; System.out.println(value.substring(0, value.length() - 1); // 遍历打印数组的值，中间用逗号分隔，去掉最后都好 &#125; &#125; &#125;); // Add a new group，添加一个组，这个用来就读值或者写值一次，而不是循环 // 组的名字随意，给组起名字是因为，server可以addGroup也可以removeGroup，读一次值，就先添加组，然后移除组，再读一次就再添加然后删除 final Group group = server.addGroup(\"test\"); // Add a new item to the group， // 将一个item加入到组，item名字就是MatrikonOPC Server或者KEPServer上面建的项的名字比如：u.u.TAG1，PLC.S7-300.TAG1 final Item item = group.addItem(itemId); // start reading，开始循环读值 access.bind(); // add a thread for writing a value every 3 seconds // 写一次就是item.write(value)，一直写就起个线程一直执行item.write(value) ScheduledExecutorService writeThread = Executors.newSingleThreadScheduledExecutor(); writeThread.scheduleWithFixedDelay(new Runnable() &#123; @Override public void run() &#123; // 单个值，如1，\"R37\"，就当字符串直接写入 final JIVariant value = new JIVariant(\"24\"); // 写入24 try &#123; System.out.println(\"&gt;&gt;&gt; \" + \"写入值： \" + \"24\"); item.write(value); &#125; catch (JIException e) &#123; e.printStackTrace(); &#125; // 如果写的值是数组类型呢，比如6位Long类型的数组 // 构造数组，前缀加(long)是因为编辑器对于数值一般按int类型处理，其他类型要指定类型 // Long[] integerData = &#123;(long) 1,(long) 2,(long) 3,(long) 4,(long) 5,(long) 6&#125;; // final JIArray array = new JIArray(integerData, false); // 这句是抄来的 // final JIVariant value = new JIVariant(array); // item.write(value); &#125; &#125;, 5, 3, TimeUnit.SECONDS); // 启动后5秒第一次执行代码，以后每3秒执行一次代码 // wait a little bit ，延时20秒 Thread.sleep(20 * 1000); writeThread.shutdownNow(); // 杀死一直读的线程 // stop reading，停止循环读值 access.unbind(); &#125; catch (final JIException e) &#123; System.out.println(String.format(\"%08X: %s\", e.getErrorCode(), server.getErrorMessage(e.getErrorCode()))); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-01-16T07:51:30.681Z","updated":"2019-01-18T08:39:15.128Z","comments":true,"path":"2019/01/16/hello-world/","link":"","permalink":"http://ious.ml/2019/01/16/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"生活","slug":"生活","permalink":"http://ious.ml/categories/生活/"}],"tags":[{"name":"计算机协议","slug":"计算机协议","permalink":"http://ious.ml/tags/计算机协议/"}]}]}